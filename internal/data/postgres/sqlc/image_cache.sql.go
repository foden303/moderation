// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: image_cache.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countImageCaches = `-- name: CountImageCaches :one
SELECT COUNT(*) FROM image_caches
`

func (q *Queries) CountImageCaches(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImageCaches)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageCachesByCategory = `-- name: CountImageCachesByCategory :one
SELECT COUNT(*) FROM image_caches WHERE category = $1
`

func (q *Queries) CountImageCachesByCategory(ctx context.Context, category string) (int64, error) {
	row := q.db.QueryRow(ctx, countImageCachesByCategory, category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteExpiredImageCaches = `-- name: DeleteExpiredImageCaches :execrows
DELETE FROM image_caches WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredImageCaches(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredImageCaches)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteImageCache = `-- name: DeleteImageCache :exec
DELETE FROM image_caches WHERE file_hash = $1
`

func (q *Queries) DeleteImageCache(ctx context.Context, fileHash string) error {
	_, err := q.db.Exec(ctx, deleteImageCache, fileHash)
	return err
}

const getAllImageCaches = `-- name: GetAllImageCaches :many
SELECT file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at FROM image_caches
`

func (q *Queries) GetAllImageCaches(ctx context.Context) ([]ImageCach, error) {
	rows, err := q.db.Query(ctx, getAllImageCaches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImageCach
	for rows.Next() {
		var i ImageCach
		if err := rows.Scan(
			&i.FileHash,
			&i.Phash,
			&i.DetectResult,
			&i.Category,
			&i.NsfwScore,
			&i.ModelVersion,
			&i.SourceUrl,
			&i.AddedBy,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImageCache = `-- name: GetImageCache :one
SELECT file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at FROM image_caches WHERE file_hash = $1
`

func (q *Queries) GetImageCache(ctx context.Context, fileHash string) (ImageCach, error) {
	row := q.db.QueryRow(ctx, getImageCache, fileHash)
	var i ImageCach
	err := row.Scan(
		&i.FileHash,
		&i.Phash,
		&i.DetectResult,
		&i.Category,
		&i.NsfwScore,
		&i.ModelVersion,
		&i.SourceUrl,
		&i.AddedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getImageCacheByPHash = `-- name: GetImageCacheByPHash :many
SELECT file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at FROM image_caches WHERE phash = $1
`

func (q *Queries) GetImageCacheByPHash(ctx context.Context, phash int64) ([]ImageCach, error) {
	rows, err := q.db.Query(ctx, getImageCacheByPHash, phash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImageCach
	for rows.Next() {
		var i ImageCach
		if err := rows.Scan(
			&i.FileHash,
			&i.Phash,
			&i.DetectResult,
			&i.Category,
			&i.NsfwScore,
			&i.ModelVersion,
			&i.SourceUrl,
			&i.AddedBy,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageCaches = `-- name: ListImageCaches :many
SELECT file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at FROM image_caches
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListImageCachesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListImageCaches(ctx context.Context, arg ListImageCachesParams) ([]ImageCach, error) {
	rows, err := q.db.Query(ctx, listImageCaches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImageCach
	for rows.Next() {
		var i ImageCach
		if err := rows.Scan(
			&i.FileHash,
			&i.Phash,
			&i.DetectResult,
			&i.Category,
			&i.NsfwScore,
			&i.ModelVersion,
			&i.SourceUrl,
			&i.AddedBy,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageCachesByCategory = `-- name: ListImageCachesByCategory :many
SELECT file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at FROM image_caches
WHERE category = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListImageCachesByCategoryParams struct {
	Category string `json:"category"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListImageCachesByCategory(ctx context.Context, arg ListImageCachesByCategoryParams) ([]ImageCach, error) {
	rows, err := q.db.Query(ctx, listImageCachesByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImageCach
	for rows.Next() {
		var i ImageCach
		if err := rows.Scan(
			&i.FileHash,
			&i.Phash,
			&i.DetectResult,
			&i.Category,
			&i.NsfwScore,
			&i.ModelVersion,
			&i.SourceUrl,
			&i.AddedBy,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertImageCache = `-- name: UpsertImageCache :one
INSERT INTO image_caches (
    file_hash, phash, detect_result,
    category, nsfw_score, model_version, source_url, added_by, expires_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (file_hash) DO UPDATE SET
    detect_result = EXCLUDED.detect_result,
    category = EXCLUDED.category,
    nsfw_score = EXCLUDED.nsfw_score,
    model_version = EXCLUDED.model_version,
    updated_at = NOW()
RETURNING file_hash, phash, detect_result, category, nsfw_score, model_version, source_url, added_by, expires_at, created_at, updated_at
`

type UpsertImageCacheParams struct {
	FileHash     string             `json:"file_hash"`
	Phash        int64              `json:"phash"`
	DetectResult []byte             `json:"detect_result"`
	Category     string             `json:"category"`
	NsfwScore    float64            `json:"nsfw_score"`
	ModelVersion string             `json:"model_version"`
	SourceUrl    string             `json:"source_url"`
	AddedBy      string             `json:"added_by"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) UpsertImageCache(ctx context.Context, arg UpsertImageCacheParams) (ImageCach, error) {
	row := q.db.QueryRow(ctx, upsertImageCache,
		arg.FileHash,
		arg.Phash,
		arg.DetectResult,
		arg.Category,
		arg.NsfwScore,
		arg.ModelVersion,
		arg.SourceUrl,
		arg.AddedBy,
		arg.ExpiresAt,
	)
	var i ImageCach
	err := row.Scan(
		&i.FileHash,
		&i.Phash,
		&i.DetectResult,
		&i.Category,
		&i.NsfwScore,
		&i.ModelVersion,
		&i.SourceUrl,
		&i.AddedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
