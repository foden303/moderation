// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v6.33.4
// source: storage/v1/file.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationFileServiceCreateFile = "/storage.v1.FileService/CreateFile"
const OperationFileServiceDeleteFilesPermanently = "/storage.v1.FileService/DeleteFilesPermanently"
const OperationFileServiceEmptyTrash = "/storage.v1.FileService/EmptyTrash"
const OperationFileServiceGetFile = "/storage.v1.FileService/GetFile"
const OperationFileServiceGetFileByHash = "/storage.v1.FileService/GetFileByHash"
const OperationFileServiceGetFilesByIDs = "/storage.v1.FileService/GetFilesByIDs"
const OperationFileServiceListFiles = "/storage.v1.FileService/ListFiles"
const OperationFileServiceListTrash = "/storage.v1.FileService/ListTrash"
const OperationFileServiceMoveFiles = "/storage.v1.FileService/MoveFiles"
const OperationFileServiceRenameFile = "/storage.v1.FileService/RenameFile"
const OperationFileServiceRestoreFiles = "/storage.v1.FileService/RestoreFiles"
const OperationFileServiceTrashFiles = "/storage.v1.FileService/TrashFiles"
const OperationFileServiceUpdateFavorite = "/storage.v1.FileService/UpdateFavorite"
const OperationFileServiceUpdateRecentAccess = "/storage.v1.FileService/UpdateRecentAccess"

type FileServiceHTTPServer interface {
	// CreateFile Create a new file
	CreateFile(context.Context, *CreateFileRequest) (*CreateFileResponse, error)
	// DeleteFilesPermanently Delete files permanently
	DeleteFilesPermanently(context.Context, *DeleteFilesPermanentlyRequest) (*DeleteFilesPermanentlyResponse, error)
	// EmptyTrash Empty trash
	EmptyTrash(context.Context, *EmptyTrashRequest) (*EmptyTrashResponse, error)
	// GetFile Get file by ID
	GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error)
	// GetFileByHash Get file by hash (for deduplication)
	GetFileByHash(context.Context, *GetFileByHashRequest) (*GetFileByHashResponse, error)
	// GetFilesByIDs Get files by IDs
	GetFilesByIDs(context.Context, *GetFilesByIDsRequest) (*GetFilesByIDsResponse, error)
	// ListFiles List files in folder (with cursor pagination)
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	// ListTrash List files in trash
	ListTrash(context.Context, *ListTrashRequest) (*ListTrashResponse, error)
	// MoveFiles Move files to folder
	MoveFiles(context.Context, *MoveFilesRequest) (*MoveFilesResponse, error)
	// RenameFile Rename file
	RenameFile(context.Context, *RenameFileRequest) (*RenameFileResponse, error)
	// RestoreFiles Restore files from trash
	RestoreFiles(context.Context, *RestoreFilesRequest) (*RestoreFilesResponse, error)
	// TrashFiles Move files to trash (soft delete)
	TrashFiles(context.Context, *TrashFilesRequest) (*TrashFilesResponse, error)
	// UpdateFavorite Update favorite status
	UpdateFavorite(context.Context, *UpdateFavoriteRequest) (*UpdateFavoriteResponse, error)
	// UpdateRecentAccess Update recent accessed time
	UpdateRecentAccess(context.Context, *UpdateRecentAccessRequest) (*UpdateRecentAccessResponse, error)
}

func RegisterFileServiceHTTPServer(s *http.Server, srv FileServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/files", _FileService_CreateFile0_HTTP_Handler(srv))
	r.GET("/v1/files/{id}", _FileService_GetFile0_HTTP_Handler(srv))
	r.POST("/v1/files/batch", _FileService_GetFilesByIDs0_HTTP_Handler(srv))
	r.GET("/v1/files", _FileService_ListFiles0_HTTP_Handler(srv))
	r.GET("/v1/files/hash/{file_hash}", _FileService_GetFileByHash0_HTTP_Handler(srv))
	r.POST("/v1/files/move", _FileService_MoveFiles0_HTTP_Handler(srv))
	r.PATCH("/v1/files/{id}/rename", _FileService_RenameFile0_HTTP_Handler(srv))
	r.PATCH("/v1/files/favorite", _FileService_UpdateFavorite0_HTTP_Handler(srv))
	r.PATCH("/v1/files/recent", _FileService_UpdateRecentAccess0_HTTP_Handler(srv))
	r.POST("/v1/files/trash", _FileService_TrashFiles0_HTTP_Handler(srv))
	r.GET("/v1/trash", _FileService_ListTrash0_HTTP_Handler(srv))
	r.POST("/v1/trash/restore", _FileService_RestoreFiles0_HTTP_Handler(srv))
	r.POST("/v1/trash/delete", _FileService_DeleteFilesPermanently0_HTTP_Handler(srv))
	r.DELETE("/v1/trash", _FileService_EmptyTrash0_HTTP_Handler(srv))
}

func _FileService_CreateFile0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateFileRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceCreateFile)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateFile(ctx, req.(*CreateFileRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateFileResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetFile0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFileRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetFile)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFile(ctx, req.(*GetFileRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFileResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetFilesByIDs0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFilesByIDsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetFilesByIDs)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFilesByIDs(ctx, req.(*GetFilesByIDsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFilesByIDsResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_ListFiles0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListFilesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceListFiles)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListFiles(ctx, req.(*ListFilesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListFilesResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetFileByHash0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFileByHashRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetFileByHash)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFileByHash(ctx, req.(*GetFileByHashRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFileByHashResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_MoveFiles0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MoveFilesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceMoveFiles)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MoveFiles(ctx, req.(*MoveFilesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MoveFilesResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_RenameFile0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RenameFileRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceRenameFile)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RenameFile(ctx, req.(*RenameFileRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RenameFileResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_UpdateFavorite0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateFavoriteRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceUpdateFavorite)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateFavorite(ctx, req.(*UpdateFavoriteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateFavoriteResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_UpdateRecentAccess0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateRecentAccessRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceUpdateRecentAccess)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateRecentAccess(ctx, req.(*UpdateRecentAccessRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateRecentAccessResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_TrashFiles0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TrashFilesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceTrashFiles)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TrashFiles(ctx, req.(*TrashFilesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TrashFilesResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_ListTrash0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTrashRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceListTrash)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTrash(ctx, req.(*ListTrashRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListTrashResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_RestoreFiles0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RestoreFilesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceRestoreFiles)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RestoreFiles(ctx, req.(*RestoreFilesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RestoreFilesResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_DeleteFilesPermanently0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteFilesPermanentlyRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceDeleteFilesPermanently)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteFilesPermanently(ctx, req.(*DeleteFilesPermanentlyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteFilesPermanentlyResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_EmptyTrash0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EmptyTrashRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceEmptyTrash)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EmptyTrash(ctx, req.(*EmptyTrashRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*EmptyTrashResponse)
		return ctx.Result(200, reply)
	}
}

type FileServiceHTTPClient interface {
	// CreateFile Create a new file
	CreateFile(ctx context.Context, req *CreateFileRequest, opts ...http.CallOption) (rsp *CreateFileResponse, err error)
	// DeleteFilesPermanently Delete files permanently
	DeleteFilesPermanently(ctx context.Context, req *DeleteFilesPermanentlyRequest, opts ...http.CallOption) (rsp *DeleteFilesPermanentlyResponse, err error)
	// EmptyTrash Empty trash
	EmptyTrash(ctx context.Context, req *EmptyTrashRequest, opts ...http.CallOption) (rsp *EmptyTrashResponse, err error)
	// GetFile Get file by ID
	GetFile(ctx context.Context, req *GetFileRequest, opts ...http.CallOption) (rsp *GetFileResponse, err error)
	// GetFileByHash Get file by hash (for deduplication)
	GetFileByHash(ctx context.Context, req *GetFileByHashRequest, opts ...http.CallOption) (rsp *GetFileByHashResponse, err error)
	// GetFilesByIDs Get files by IDs
	GetFilesByIDs(ctx context.Context, req *GetFilesByIDsRequest, opts ...http.CallOption) (rsp *GetFilesByIDsResponse, err error)
	// ListFiles List files in folder (with cursor pagination)
	ListFiles(ctx context.Context, req *ListFilesRequest, opts ...http.CallOption) (rsp *ListFilesResponse, err error)
	// ListTrash List files in trash
	ListTrash(ctx context.Context, req *ListTrashRequest, opts ...http.CallOption) (rsp *ListTrashResponse, err error)
	// MoveFiles Move files to folder
	MoveFiles(ctx context.Context, req *MoveFilesRequest, opts ...http.CallOption) (rsp *MoveFilesResponse, err error)
	// RenameFile Rename file
	RenameFile(ctx context.Context, req *RenameFileRequest, opts ...http.CallOption) (rsp *RenameFileResponse, err error)
	// RestoreFiles Restore files from trash
	RestoreFiles(ctx context.Context, req *RestoreFilesRequest, opts ...http.CallOption) (rsp *RestoreFilesResponse, err error)
	// TrashFiles Move files to trash (soft delete)
	TrashFiles(ctx context.Context, req *TrashFilesRequest, opts ...http.CallOption) (rsp *TrashFilesResponse, err error)
	// UpdateFavorite Update favorite status
	UpdateFavorite(ctx context.Context, req *UpdateFavoriteRequest, opts ...http.CallOption) (rsp *UpdateFavoriteResponse, err error)
	// UpdateRecentAccess Update recent accessed time
	UpdateRecentAccess(ctx context.Context, req *UpdateRecentAccessRequest, opts ...http.CallOption) (rsp *UpdateRecentAccessResponse, err error)
}

type FileServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewFileServiceHTTPClient(client *http.Client) FileServiceHTTPClient {
	return &FileServiceHTTPClientImpl{client}
}

// CreateFile Create a new file
func (c *FileServiceHTTPClientImpl) CreateFile(ctx context.Context, in *CreateFileRequest, opts ...http.CallOption) (*CreateFileResponse, error) {
	var out CreateFileResponse
	pattern := "/v1/files"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceCreateFile))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteFilesPermanently Delete files permanently
func (c *FileServiceHTTPClientImpl) DeleteFilesPermanently(ctx context.Context, in *DeleteFilesPermanentlyRequest, opts ...http.CallOption) (*DeleteFilesPermanentlyResponse, error) {
	var out DeleteFilesPermanentlyResponse
	pattern := "/v1/trash/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceDeleteFilesPermanently))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// EmptyTrash Empty trash
func (c *FileServiceHTTPClientImpl) EmptyTrash(ctx context.Context, in *EmptyTrashRequest, opts ...http.CallOption) (*EmptyTrashResponse, error) {
	var out EmptyTrashResponse
	pattern := "/v1/trash"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceEmptyTrash))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetFile Get file by ID
func (c *FileServiceHTTPClientImpl) GetFile(ctx context.Context, in *GetFileRequest, opts ...http.CallOption) (*GetFileResponse, error) {
	var out GetFileResponse
	pattern := "/v1/files/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceGetFile))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetFileByHash Get file by hash (for deduplication)
func (c *FileServiceHTTPClientImpl) GetFileByHash(ctx context.Context, in *GetFileByHashRequest, opts ...http.CallOption) (*GetFileByHashResponse, error) {
	var out GetFileByHashResponse
	pattern := "/v1/files/hash/{file_hash}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceGetFileByHash))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetFilesByIDs Get files by IDs
func (c *FileServiceHTTPClientImpl) GetFilesByIDs(ctx context.Context, in *GetFilesByIDsRequest, opts ...http.CallOption) (*GetFilesByIDsResponse, error) {
	var out GetFilesByIDsResponse
	pattern := "/v1/files/batch"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceGetFilesByIDs))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListFiles List files in folder (with cursor pagination)
func (c *FileServiceHTTPClientImpl) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...http.CallOption) (*ListFilesResponse, error) {
	var out ListFilesResponse
	pattern := "/v1/files"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceListFiles))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListTrash List files in trash
func (c *FileServiceHTTPClientImpl) ListTrash(ctx context.Context, in *ListTrashRequest, opts ...http.CallOption) (*ListTrashResponse, error) {
	var out ListTrashResponse
	pattern := "/v1/trash"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceListTrash))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MoveFiles Move files to folder
func (c *FileServiceHTTPClientImpl) MoveFiles(ctx context.Context, in *MoveFilesRequest, opts ...http.CallOption) (*MoveFilesResponse, error) {
	var out MoveFilesResponse
	pattern := "/v1/files/move"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceMoveFiles))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// RenameFile Rename file
func (c *FileServiceHTTPClientImpl) RenameFile(ctx context.Context, in *RenameFileRequest, opts ...http.CallOption) (*RenameFileResponse, error) {
	var out RenameFileResponse
	pattern := "/v1/files/{id}/rename"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceRenameFile))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// RestoreFiles Restore files from trash
func (c *FileServiceHTTPClientImpl) RestoreFiles(ctx context.Context, in *RestoreFilesRequest, opts ...http.CallOption) (*RestoreFilesResponse, error) {
	var out RestoreFilesResponse
	pattern := "/v1/trash/restore"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceRestoreFiles))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TrashFiles Move files to trash (soft delete)
func (c *FileServiceHTTPClientImpl) TrashFiles(ctx context.Context, in *TrashFilesRequest, opts ...http.CallOption) (*TrashFilesResponse, error) {
	var out TrashFilesResponse
	pattern := "/v1/files/trash"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceTrashFiles))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateFavorite Update favorite status
func (c *FileServiceHTTPClientImpl) UpdateFavorite(ctx context.Context, in *UpdateFavoriteRequest, opts ...http.CallOption) (*UpdateFavoriteResponse, error) {
	var out UpdateFavoriteResponse
	pattern := "/v1/files/favorite"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceUpdateFavorite))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateRecentAccess Update recent accessed time
func (c *FileServiceHTTPClientImpl) UpdateRecentAccess(ctx context.Context, in *UpdateRecentAccessRequest, opts ...http.CallOption) (*UpdateRecentAccessResponse, error) {
	var out UpdateRecentAccessResponse
	pattern := "/v1/files/recent"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceUpdateRecentAccess))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
